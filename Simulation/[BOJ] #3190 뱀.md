## [BOJ] #3190 뱀

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 128 MB      | 31.052%   |

https://www.acmicpc.net/problem/3190



testcase 1

>20
>13
>6 15
>7 18
>20 14
>14 13
>11 9
>7 10
>3 18
>10 10
>13 13
>13 5
>6 9
>10 4
>4 3
>19
>17 D
>36 D
>41 D
>54 D
>56 L
>57 L
>63 L
>68 L
>72 L
>73 L
>76 D
>79 D
>82 D
>85 D
>87 D
>93 L
>105 D
>110 D
>114 D

정답 90

testcase 2

>5
>2
>2 5
>2 4
>6
>4 D
>5 D
>6 D
>7 D
>8 D
>9 D

정답 14

| 메모리  | 시간 |
| ------- | ---- |
| 1160 KB | 0 ms |

```c++
#include <cstdio>
#include <string.h>
#include <algorithm>
#include <queue>
using namespace std;
int arr[105][105];
int n, K, L, i, idx, tail_idx, dir, tail_dir; //idx 는 turn 의 인덱스 번호, dir 은 머리 방향, tail_dir은 꼬리 방향
int dx[] = { 0, 1, 0, -1 };
int dy[] = { 1, 0, -1, 0 };
pair<int, char> turn[105];
pair<int, int> tail;
// 사과는 1, 뱀은 2, 아무것도 없으면 0
int main(){	
	scanf("%d %d", &n, &K);
	for (int i = 0, a, b; i < K; i++) {
		scanf("%d %d", &a, &b);
		arr[a][b] = 1; // 사과
	}
	scanf("%d", &L);
	int X; char C;
	for (int i = 0; i < L; i++) {
		scanf("%d %c", &X, &C);
		turn[i] = { X, C };
	}
	int r = 1, c = 1, sec = 0, cnt = 0;
	arr[1][1] = 2;
	tail = { 1,1 };
	while (r >= 1 && r <= n && c >= 1 && c <= n) {
		int tf = turn[idx].first;	char ts = turn[idx].second;
		
		r = r + dx[dir]; c = c + dy[dir];
		sec++;
		if (arr[r][c] == 2) {
			break;
		}
		if (!arr[r][c]) { // 꼬리가 위치한 칸을 당겨준다.
			cnt++;
			arr[tail.first][tail.second] = 0;
			tail.first = tail.first + dx[tail_dir]; tail.second = tail.second + dy[tail_dir];
		}
		if (sec == tf) { // 머리 방향전환
			dir = ts == 'L' ? (dir + 3) % 4 : (dir + 1) % 4;
			idx++;
		}
		if (cnt == turn[tail_idx].first) { // 꼬리 방향전환
			tail_dir = turn[tail_idx].second == 'L' ? (tail_dir + 3) % 4 : (tail_dir + 1) % 4;
			tail_idx++;
		}		
		arr[r][c] = 2;
	}
	printf("%d", sec);
	return 0;
}
```





백준 3190 뱀 boj acmicpc

