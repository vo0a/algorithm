## [BOJ] #17144 미세먼지 안녕!

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 512 MB      | 54.847%   |

https://www.acmicpc.net/problem/17144



memset 헤더를 지정안해줘서 한 번 컴파일 에러가 나왔다. 
memset을 쓸 때 string.h 헤더 잊지 않기!

| 메모리  | 시간  |
| ------- | ----- |
| 2012 KB | 40 ms |

```c++
#include<iostream>
#include<string.h>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
typedef pair<int, int> p;
int n, m, t, arr[55][55], tmp[55][55], ans; // t초 후 미세먼지의 양을 출력.
int dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 };
vector<int> aircleaner;
void spread(int r, int c) {
	int& A = arr[r][c];
	int cnt = 0;
	for (int i = 0; i < 4; i++) {
		int nr = r + dx[i]; 	int nc = c + dy[i];
		if (arr[nr][nc] != -1 && nr >= 0 && nr < n && nc >= 0 && nc < m) {
			tmp[nr][nc] += (A / 5); cnt++;
		}
	}
	A -= (A / 5) * cnt;
}
int main() {
	scanf("%d%d%d", &n, &m, &t);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			scanf("%d", &arr[i][j]);
			if (arr[i][j] == -1)aircleaner.push_back(i);
		}
	}
	while (t--) {
		// 미세먼지 확산
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (arr[i][j] > 0) 
					spread(i, j);
			}
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				arr[i][j] += tmp[i][j];
			}
		}
		memset(tmp, 0, sizeof(tmp));
		// 공기 순환
		int row_ccw = aircleaner[0]; // counterclockwise
		int row_cw = aircleaner[1]; //clockwise
		for (int i = row_ccw - 1; i > 0; i--) {
			arr[i][0] = arr[i - 1][0];
		}
		for (int i = row_cw + 1; i < n - 1; i++) {
			arr[i][0] = arr[i + 1][0];
		}
		for (int j = 0; j < m - 1; j++) {
			arr[0][j] = arr[0][j + 1];
			arr[n - 1][j] = arr[n - 1][j + 1];
		}
		for (int i = 0; i < row_ccw; i++) {
			arr[i][m - 1] = arr[i + 1][m - 1];
		}
		for (int i = n - 1; i > row_cw; i--) {
			arr[i][m - 1] = arr[i - 1][m - 1];
		}
		for (int j = m - 1; j > 1; j--) {
			arr[row_ccw][j] = arr[row_ccw][j - 1];
		}	
		for (int j = m - 1; j > 1; j--) {
			arr[row_cw][j] = arr[row_cw][j - 1];
		}
		arr[row_ccw][1] = 0; arr[row_cw][1] = 0;
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (arr[i][j] != -1)ans += arr[i][j];
		}
	}
	printf("%d", ans);
	return 0;
}
```



### memset 대신 쓸 수 있는 방법 

while 문 안에 지역변수로 int tmp[55\][55] = {0}; 이와 같이 선언하면 memset 함수가 필요 없음.



### for 문 더 간편하게 쓰기

```c++
#define F(x,y,u,p) for(int x=0; x<u; x++)for(int y=0;y<p;y++)

F(i, j, R, C) {
    if (a[i][j] > 4) {
        int n = a[i][j] / 5, m = 0;
        for (int d = 0; d < 4; d++) { 
            int ni = i + dd[d][0], nj = j + dd[d][1]; 
            if (chk(ni, nj)) { ta[ni][nj] += n; m++; } 
        }
        a[i][j] -= n * m;
    }
}
```

정의문으로 for 문을 정의해두면 간편하고 실수없이 사용할 수 있다.



### 배열 순환 더 쉽게하기

```c++
int dd[4][2] = { {0,1},{-1,0},{0,-1},{1,0} }, dx[8] = { 0,1,2,3,0,3,2,1 };

for (int i = 0; i < 2; i++) {
    int cn = 0, cm = 0, ii = q[i][0], jj = q[i][1];
    while (1) {
        int ni = ii + dd[dx[cz]][0], nj = jj + dd[dx[cz]][1];
        if (ni == q[i][0] && nj == 0) { cz++; break; }
        if (chk(ni, nj)) { 
            cm = a[ni][nj]; 
            a[ni][nj] = cn; 
            cn = cm; 
            ii = ni; jj = nj; 
        }
        else cz++;
    }
}
```



### 전체 코드

```c++
#include <iostream>
using namespace std;

#define F(x,y,u,p) for(int x=0; x<u; x++)for(int y=0;y<p;y++)
int ans, w, q[2][2], R, C, T, a[50][50], dd[4][2] = { {0,1},{-1,0},{0,-1},{1,0} }, dx[8] = { 0,1,2,3,0,3,2,1 };

inline bool chk(int i, int j) { return (i < 0 || j < 0 || i >= R || j >= C || a[i][j] < 0) ? false : true; }

int main() {
	cin >> R >> C >> T;
	F(i, j, R, C) { cin >> a[i][j]; if (a[i][j] < 0)q[w][0] = i, q[w++][1] = j; }
	while (T--) {
		int ta[50][50] = { 0, }, cz = 0;
		F(i, j, R, C) {
			if (a[i][j] > 4) {
				int n = a[i][j] / 5, m = 0;
				for (int d = 0; d < 4; d++) { int ni = i + dd[d][0], nj = j + dd[d][1]; if (chk(ni, nj)) { ta[ni][nj] += n; m++; } }
				a[i][j] -= n * m;
			}
		}
		F(i, j, R, C) a[i][j] += ta[i][j];
		for (int i = 0; i < 2; i++) {
			int cn = 0, cm = 0, ii = q[i][0], jj = q[i][1];
			while (1) {
				int ni = ii + dd[dx[cz]][0], nj = jj + dd[dx[cz]][1];
				if (ni == q[i][0] && nj == 0) { cz++; break; }
				if (chk(ni, nj)) { cm = a[ni][nj]; a[ni][nj] = cn; cn = cm; ii = ni; jj = nj; }
				else cz++;
			}
		}
	}
	F(i, j, R, C) if (a[i][j] > 0) ans += a[i][j];
	cout << ans;
	return 0;
}
```





백준 17144 미세먼지 안녕! boj acmicpc

