## [BOJ] #1783 병든 나이트

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 128 MB      | 43.094%   |

[문제](https://www.acmicpc.net/problem/1783)



| 메모리  | 시간 |
| ------- | ---- |
| 2016 KB | 0 ms |

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
	int height, width;
	scanf("%d%d", &height, &width);
	if (height == 1) {
		printf("1");
	}
	else if (height == 2) {
		printf("%d", min(4, (width + 1) / 2));
	}
	else if (height >= 3) {
		if (width >= 7) {
			printf("%d", width - 2);
		}
		else {
			printf("%d", min(4, width));
		}
	}
	return 0;
}
```

- n, m 제한이 20억이면 for문과 배열에 제한있다. 
- 보통 n, m제한이 1억이 넘는 경우에는 수식으로 해결되는 경우가 많다.

### 수식

높이에 따라 3가지 경우로 나뉘게 된다.

1. 높이가 1일 때

   - 이동할 수 없으므로 현재위치인 칸만 방문하므로 답은 `1`이 된다.

2. 높이가 2 일 때

   - (1, 2), (-1, 2) 두 가지 경우밖에 사용할 수 없다.
   - 너비가 1, 2일때는 `1칸 방문`, 3, 4일 때는 `2칸 방문`, 5, 6일때는 `3칸 방문` , 7, 8일때는 `4칸 방문`, 9, 10칸일 때는 `5칸이 방문` 가능하다.
   - 그런데 조건에서 방문할 수 있는 칸의 개수가 4칸 초과(5칸 이상)일 때는 무조건 4가지 방법을 모두 사용하는 제약이 있기 때문에 수식은
   - `min(4, (width + 1) / 2)` 가 된다.

3. 높이가 3 이상일 때

   이 경우에는 너비에 따라 두 가지 경우로 나뉜다.

   1. width >= 7
      - 병든 나이트가 움직이는 4가지 방법을 모두 사용하기 위해서는 `너비가 최소 7`은 되어야 한다. 
      - 4가지 방법을 이용해서 이동하는 동안 적어도 `5칸`을 방문할 수 있다.
      - 4가지 방법을 모두 이용한 이후에는 (2, 1), (-2, 1) 두 가지 방법을 반복하면 너비 1칸 마다 1칸씩 방문할 수 있다.
      - 위의 세가지를 종합해보면, 너비가 7이상일 때는 `width - 2`가 된다.
        - -2 에 해당하는 의미는 첫번째 4가지 방법을 모두 사용할 때 방문하지 못하는 칸에 해당한다.
   2. width < 7
      - 너비가 7미만이면서 높이가 3인 경우에는 4가지 방법을 모두 사용할 수 없고, (2, 1), (-2, 1) 두 가지 방법을 반복하는 것이 최대이기 때문에 width 그 자체가 답이된다.
      - 하지만 이 경우에도 너비가 5와 6인 경우에는 제약사항에 걸리기 때문에 `min(4, width)` 가 된다.



백준 1783 병든 나이트 boj acmicpc

