## [BOJ] #2056 작업

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 256 MB      | 41.071%   |

[문제](https://www.acmicpc.net/problem/2056)



| 메모리   | 시간   |
| -------- | ------ |
| 13164 KB | 140 ms |

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
int n, time[2][10005], indegree[10005], number[10005], seq = 1, ans;
int dp[10005];
vector<vector<int>> adj;
vector<vector<int>> tmp; // 그래프 개수 판별 인접리스트
queue<int> q;

void numbering(int i) {
	number[i] = seq;
	for (auto e : tmp[i]) {
		if (number[e]) continue;
		numbering(e);
	}
}

int main() {
	scanf("%d", &n);
	adj.resize(n + 1);
	tmp.resize(n + 1);
	for (int i = 1, a, b; i <= n; i++) {
		scanf("%d%d", &time[0][i],&a);
		time[1][i] = time[0][i];		
		while (a--) {
			scanf("%d", &b);
			adj[b].push_back(i);
			indegree[i]++;

			tmp[b].push_back(i);
			tmp[i].push_back(b);						
		}
	}

	// 그래프 번호 매기기
	for (int i = 1; i <= n; i++) {
		if (!number[i]) {
			numbering(i);
			seq++;
		}
	}	

	// 위상정렬
	for (int i = 1; i <= n; i++) {
		if (!indegree[i]){
			q.push(i); // 노드번호, 그래프 번호
		}
	}
	
	while (!q.empty()) {
		int front = q.front();
		q.pop();
		int t = time[1][front];
		dp[number[front]] = max(t, dp[number[front]]);

		for (auto e : adj[front]) {
			time[1][e] = max(t + time[0][e], time[1][e]);
			if (--indegree[e] == 0) {
				q.push(e);
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		if (dp[i]) {
			ans = max(ans, dp[i]);
		}
	}
	printf("%d", ans);
	
	return 0;
}
```

테스트 케이스

```
7
5 0
1 0
3 0
6 0
1 0
8 0
4 0
8

7
5 0
1 1 1
1 0
6 1 1
1 1 3
8 1 3
4 1 2
11

3
100 0
10 0
5 2 1 2
105
```



### 틀렸던 이유

- 같은 그래프인데도 서로 다른 그래프로 판단했기 때문에 오답이 나왔음. 
- 그래프 판단을 어떻게 해야 할까?
  - 가장 먼저 떠오른 생각은, 위상정렬을 하기 전 입력을 받을 때, 양방향 그래프로 만들어서 해당 노드가 몇번째 그래프에 속하는지 판별하는 작업을 해야겠다고 생각했다.
  - tmp 벡터를 사용해서 numbering() 메소드로 DFS돌면서 그래프 번호 매긴 후, 위상정렬로 dp를 채웠다.

조금 풀어쓰면 아래와 같다.

```
그래프가 여러개일 때를 고려해서 dp[i]에 i번째 그래프의 모든 작업을 완료하기 위해 필요한 최소 시간을 저장해서 마지막에 ans에 모든 dp값을 더해서 출력하고 있습니다.

서로 다른 그래프인지, 같은 그래프인지 판별은 tmp라는 벡터를 사용했고, numbering() 메소드로 단순 DFS를 하며 판단했고, 그 후 위상정렬을 통해서 dp[i]를 채워나갔습니다.
그후 dp[i]의 max값을 구하여 출력하면 된다.
```





백준 2056 작업 boj acmicpc

