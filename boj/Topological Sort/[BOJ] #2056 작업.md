## [BOJ] #2056 작업

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 256 MB      | 41.071%   |

[문제](https://www.acmicpc.net/problem/2056)



| 메모리 | 시간 |
| ------ | ---- |
| KB     | 0 ms |

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
typedef pair<int, int> p;
int n, time[2][10005], indegree[10005];
int dp[10005];
vector<vector<int>> adj;
queue<p> q;
int main() {
	scanf("%d", &n);
	adj.resize(n + 1);
	for (int i = 1, a, b; i <= n; i++) {
		scanf("%d%d", &time[0][i],&a);
		time[1][i] = time[0][i];		
		while (a--) {
			scanf("%d", &b);
			adj[b].push_back(i);
			indegree[i]++;			
		}
	}
	int j = 1;
	for (int i = 1; i <= n; i++) {
		if (!indegree[i]){
			q.push({ i, j++ }); // 노드번호, 그래프 번호
		}
	}
	int ans = 0;
	while (!q.empty()) {
		int front = q.front().first, seq = q.front().second;
		q.pop();
		int t = time[1][front];
		dp[seq] = max(t, dp[seq]);

		for (auto e : adj[front]) {
			time[1][e] = max(t + time[0][e], time[1][e]);
			if (--indegree[e] == 0) {
				q.push({ e , seq});
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (dp[i]) {
			ans += dp[i];
		}
	}
	printf("%d", ans);
	
	return 0;
}
```

- 반례 찾아서 고쳐봤는데도 틀림... 다른 반례 찾아보기..

```
7
5 0
1 0
3 0
6 0
1 0
8 0
4 0
```





백준 2056 작업 boj acmicpc

