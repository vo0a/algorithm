## [BOJ] #1720 타일 코드

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 128 MB      | 44.222%   |

[문제](https://www.acmicpc.net/problem/1720)



| 메모리  | 시간 |
| ------- | ---- |
| 1116 KB | 0 ms |

```c++
#include <cstdio>
int a[31]; // 대칭 포함
int d[31]; // 대칭 없음
int main() {
	a[1] = 1;
	a[2] = 3;
    // 대칭 + 비대칭
	for (int i = 3; i <= 30; i++) {
		a[i] = a[i - 1] + a[i - 2] * 2;
	}
	d[1] = 1;
	d[2] = 3;
    // 대칭인 경우만 구함
	for (int i = 3; i <= 30; i++) {
		int b = 0;
		if (i % 2 == 1) {
			b = a[(i - 1) / 2];
		}
		else {
			b = a[i / 2] + 2 * a[(i - 2) / 2];
		}
        // 전부 두 개씩 만들고 /2 해줌
		d[i] = (a[i] + b) / 2;
	}
	int n;
	scanf("%d", &n);
	printf("%d", d[n]);
	return 0;
}
```

```c++
#include <cstdio>
long long dp[40];
int main(){
  int n;
  scanf("%d",&n);
  dp[0]=1;
  dp[1]=1;
  dp[2]=3;
  for(int i=3;i<32;i++)
    dp[i] = dp[i-1] + dp[i-2] * 2;
    
  if(n % 2)
    printf("%lld",(dp[n] + dp[n / 2]) / 2);
  else
    printf("%lld",(dp[n] + dp[n / 2] + dp[n / 2 - 1] * 2) / 2);
  return 0;
}
```

- 타일모양은 `대칭` / `비대칭` 으로 나눌 수 있다.
- 대칭 인경우에는 좌우 반전이 같으므로 언제나 경우의 수가 1이다.
- 비대칭인 경우에는 좌우 반전이 가능하므로 경우의 수가 2개씩 만들어질 수 있다. 하지만 문제에서는 좌우 반전인 경우를 제외하고 싶다.
- 따라서 대칭인경우를 두 번 더해서 `(대칭 + 대칭 + 비대칭)/ 2` 를 한다면 **중복된 표현을 한 가지 경우로 처리**할 수 있다. 
  - 대칭과 비대칭을 모두 포함한 경우는 `dp[i] = dp[i-1] + dp[i-2] * 2` 를 통해서 구할 수 있다. → `대칭 + 비대칭`
  - 그렇다면, 대칭인 경우를 찾아서 한 번 더 더해야 한다. → `대칭`
  - 대칭찾기
    - 홀수인 경우
      - 가운데 1 * 2 타일 하나가 있고 좌우 대칭일 수 있다.
        - dp[n / 2] 을 더해줌 
        - ∴ `dp[n] + dp[n / 2]`
    - 짝수인 경우
      - 반으로 나누었을 때 양 옆이 대칭
        - dp[n / 2]
      - 가운데 1 * 2 타일 두개 or 2 * 2 타일 하나 넣고 좌우 대칭
        - dp[n / 2 - 1] * 2
      - ∴ `dp[n] + dp[n / 2] + dp[n / 2 - 1] * 2`
- 이제 `대칭 + 대칭 + 비대칭` 의 값을 찾았으므로 /2를 한다.
  - `(dp[n] + dp[n / 2]) / 2`
  - `(dp[n] + dp[n / 2] + dp[n / 2 - 1] * 2) / 2`





백준 1720 타일 코드 boj acmicpc

