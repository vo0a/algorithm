## [BOJ] #2579 계단 오르기

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 128 MB      | 34.848%   |

[문제](https://www.acmicpc.net/problem/2579)



| 메모리  | 시간 |
| ------- | ---- |
| 2024 KB | 0 ms |

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int N;
int arr[305], dp[305];
int main() {
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		scanf("%d", &arr[i]);
	}

	dp[0] = arr[0];
	dp[1] = arr[0] + arr[1];
	dp[2] = max(arr[1] + arr[2], arr[0] + arr[2]);
	for (int i = 3; i < N; i++) {
		dp[i] = max(dp[i - 2], dp[i - 3] + arr[i - 1]) + arr[i];
	}

	printf("%d", dp[N - 1]);
}
```

- 계단 오르는 데는 다음과 같은 규칙이 있다.

  1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
  2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
  3. 마지막 도착 계단은 반드시 밟아야 한다.

  각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하시오

- i 번째 계단의 최댓값을 구하기 위해서 i-1, i-2 번째 계단의 최댓값을 고려하려고 했더니, 연속 3개의 계단을 모두 밟는 경우가 생겨서 틀리게 된다.
- 그래서 `i 번 계단에 올라갈 수 있는 경우`를 잘 생각해보면, `i - 2번째 계단에서 두 칸 점프`하는 경우와, `i -3 번째 계단에서 i - 1번 계단을 밟고 올라가는 경우` 두 가지가 있다.
- 이를 점화식으로 나타내면 `dp[i] = max(dp[i - 2], dp[i - 3] + arr[i - 1]) + arr[i];` 이렇게 된다.
- 또한 초기화할 때 dp[2] 인 경우 연속 3개의 계단을 밟지 않도록 주의해서 초기화시켜야 한다. 



백준 2579 계단 오르기 boj acmicpc

