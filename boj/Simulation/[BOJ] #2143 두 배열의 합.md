## [BOJ] #2143 두 배열의 합

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 64 MB       | 27.919%   |

[문제](https://www.acmicpc.net/problem/2143)



죄다 long long 으로 바꿔야 맞았습니다...

| 메모리   | 시간  |
| -------- | ----- |
| 17640 KB | 64 ms |

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n, m;
long long t, a[1005], b[1005];
long long apSum[1005], bpSum[1005];

long long A[1000005], B[1000005];

int main() {
	scanf("%lld %d", &t, &n);
	for (int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		apSum[i] = apSum[i - 1] + a[i];
	}
	scanf("%d", &m);
	for (int i = 1; i <= m; i++) {
		scanf("%lld", &b[i]);
		bpSum[i] = bpSum[i - 1] + b[i];
	}

	int ap = 0, bp = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			A[ap++] = apSum[j] - apSum[i - 1];
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = i; j <= m; j++) {
			B[bp++] = bpSum[j] - bpSum[i - 1];
		}
	}
	sort(A, A + ap);
	sort(B, B + bp);

	int l = 0, r = bp - 1;
	long long sum = A[l] + B[r], ans = 0;
	while (l < ap && r >= 0) {
		if (sum == t) {
			long long cntA = 0, cntB = 0;
			long long curA = A[l], curB = B[r];
			while (l < ap && A[l] == curA) {
				cntA++; l++;
			}
			while (r >= 0 && B[r] == curB) {
				cntB++; r--;
			}
			ans += cntA * cntB;
			sum = A[l] + B[r];
		}
		else if (sum > t) {
			sum -= B[r--]; sum += B[r];
		}
		else {
			sum -= A[l++]; sum += A[l];
		}
	}
	printf("%lld", ans);
	return 0;
}
```





백준 2143 두 배열의 합 boj acmicpc

