## [BOJ] #12100 2048

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 512 MB      | 23.670%   |

[문제](https://www.acmicpc.net/problem/12100)



| 메모리  | 시간 |
| ------- | ---- |
| 1988 KB | 8 ms |

```c++
#include <iostream>
using namespace std;

int dir[4][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 상하좌우 0,1,2,3
int n, arr[25][25], Max;

void arr_copy(int a[][25], int arr[][25]) {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			a[i][j] = arr[i][j];
		}
	}
}


void go(int arr[25][25], int d, int cnt) {
	if (cnt > 5) {
		return;
	}

	int a[25][25] = { 0 };
	arr_copy(a, arr);

	// 만들고나서 현재 가장 큰 값
	int tMax = 0, chk[25][25] = { 0 };
	if (d > -1) {
		switch (d)
		{
		case 0:  // 상
			for (int j = 0; j < n; j++) {
				int i = 0;
				while (i < n - 1) {
					if (a[i][j]) {
						// 당길 숫자의 위치 찾기
						int idx = i + 1;
						while (!a[idx][j] && idx < n) {
							idx++;
						}
						if (!chk[idx][j] && a[i][j] == a[idx][j]) {
							chk[i][j] = chk[idx][j] = 1;
							a[i][j] *= 2;
							a[idx][j] = 0;
							tMax = a[i][j] > tMax ? a[i][j] : tMax;
						}
					}
					i++;
				}
			}
			// 빈공간 당기기 0이면 가장 가까운 숫자 찾아서 가져오기
			for (int j = 0; j < n; j++) {
				int i = 0;
				while (i < n - 1) {
					if (!a[i][j]) {
						// 당길 숫자의 위치 찾기
						int idx = i + 1;
						while (!a[idx][j] && idx < n) {
							idx++;
						}
						a[i][j] = a[idx][j];
						a[idx][j] = 0;
					}
					i++;
				}
			}
			break;
		case 1:  // 하
			for (int j = 0; j < n; j++) {
				int i = n - 1;
				while (i > 0) {
					if (a[i][j]) {
						// 당길 숫자의 위치 찾기
						int idx = i - 1;
						while (!a[idx][j] && idx > 0) {
							idx--;
						}
						if (!chk[idx][j] && a[i][j] == a[idx][j]) {
							chk[i][j] = chk[idx][j] = 1;
							a[i][j] *= 2;
							a[idx][j] = 0;
							tMax = a[i][j] > tMax ? a[i][j] : tMax;
						}
					}
					i--;
				}
			}
			// 빈공간 당기기 0이면 가장 가까운 숫자 찾아서 가져오기
			for (int j = 0; j < n; j++) {
				int i = n - 1;
				while (i > 0) {
					if (!a[i][j]) {
						// 당길 숫자의 위치 찾기
						int idx = i - 1;
						while (!a[idx][j] && idx > 0) {
							idx--;
						}
						a[i][j] = a[idx][j];
						a[idx][j] = 0;
					}
					i--;
				}
			}
			break;
		case 2:  // 좌
			for (int i = 0; i < n; i++) {
				int j = 0;
				while (j < n - 1) {
					if (a[i][j]) {
						int idx = j + 1;
						while (!a[i][idx] && idx < n) {
							idx++;
						}
						if (!chk[i][idx] && a[i][j] == a[i][idx]) {
							chk[i][j] = chk[i][idx] = 1;
							a[i][j] *= 2;
							a[i][idx] = 0;
							tMax = a[i][j] > tMax ? a[i][j] : tMax;
						}
					}
					j++;
				}
			}
			// 빈공간 당기기 0이면 가장 가까운 숫자 찾아서 가져오기
			for (int i = 0; i < n; i++) {
				int j = 0;
				while (j < n - 1) {
					if (!a[i][j]) {
						int idx = j + 1;
						while (!a[i][idx] && idx < n - 1) {
							idx++;
						}
						a[i][j] = a[i][idx];
						a[i][idx] = 0;
					}
					j++;
				}
			}
			break;
		case 3: // 우
			for (int i = 0; i < n; i++) {
				int j = n - 1;
				while (j > 0) {
					if (a[i][j]) {
						int idx = j - 1;
						while (!a[i][idx] && idx > 0) {
							idx--;
						}
						if (!chk[i][idx] && a[i][j] == a[i][idx]) {
							chk[i][j] = chk[i][idx] = 1;
							a[i][j] *= 2;
							a[i][idx] = 0;
							tMax = a[i][j] > tMax ? a[i][j] : tMax;
						}
					}
					j--;
				}
			}
			// 빈공간 당기기 0이면 가장 가까운 숫자 찾아서 가져오기
			for (int i = 0; i < n; i++) {
				int j = n - 1;
				while (j > 0) {
					if (!a[i][j]) {
						int idx = j - 1;
						while (!a[i][idx] && idx > 0) {
							idx--;
						}
						a[i][j] = a[i][idx];
						a[i][idx] = 0;
					}
					j--;
				}
			}
			break;
		}
	}

	Max = tMax > Max ? tMax : Max;

	for (int i = 0; i < 4; i++) {
		go(a, i, cnt + 1);
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%d", &arr[i][j]);
			Max = arr[i][j] > Max ? arr[i][j] : Max;
		}
	}

	go(arr, -1, 0);

	printf("%d", Max);

	return 0;
}
```



testcase

```
3
2 2 2
4 4 4
8 8 8
16


9
4 2 0 0 0 0 0 0 0
4 8 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0
8 0 0 0 0 0 0 0 0
8 4 0 0 0 0 0 0 0
8 2 0 0 0 0 0 0 0
64

3
0 8 1024
4 0 4
0 1024 32
2048

3
256 8 128
16 0 256
0 8 0
512
```



처음에 배열 범위가 1024인줄 알고 매개변수로 줄 때 고생이 많았다.. 휴 어쩐지,,

생각나는 대로 상하좌우에 대해서 일일이 코드를 짰는데 함수로 효율적으로 바꿀 수 있는 방법을 찾아봐야할 것 같다.



백준 12100 2048 boj acmicpc

