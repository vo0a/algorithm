## [BOJ] #12100 2048

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 2 초      | 512 MB      | 46.685%   |

[문제](https://www.acmicpc.net/problem/12100)



| 메모리  | 시간 |
| ------- | ---- |
| 1992 KB | 0 ms |

```c++
#include <iostream>
using namespace std;

int dir[4][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 상하좌우 0,1,2,3
int n, arr[1025][1025], Max;

void go(int a[][1025], int d, int cnt) {
	if (cnt > 5) {
		return;
	}

	// 만들고나서 현재 가장 큰 값
	int tMax = 0, chk[1025][1025] = { 0 };
	if (d > -1) {
		switch (d)
		{
		case 0: { // 상
			for (int i = 0; i < n - 1; i++) {
				for (int j = 0; j < n; j++) {
					if (chk[i][j]) continue;
					if (a[i][j] == a[i + 1][j]) {
						chk[i][j] = chk[i + 1][j] = 1;
						a[i][j] = a[i][j] * 2;
						a[i + 1][j] = 0;
						tMax = a[i][j] > tMax ? a[i][j] : tMax;
					}
				}
			}
			// 빈공간 당기기
			for (int i = 0; i < n - 1; i++) {
				for (int j = 0; j < n; i++) {
					if (chk[i][j] && !a[i][j]) {
						a[i][j] = a[i + 1][j];
						a[i + 1][j] = 0;
						chk[i + 1][j] = 1;
					}
				}

			}
			break;
		}
		case 1: { // 하
			for (int i = n; i > 0; i--) {
				for (int j = 0; j < n; j++) {
					if (chk[i][j]) continue;
					if (a[i][j] == a[i - 1][j]) {
						chk[i][j] = chk[i - 1][j] = 1;
						a[i][j] = a[i][j] * 2;
						a[i - 1][j] = 0;
						tMax = a[i][j] > tMax ? a[i][j] : tMax;
					}
				}
			}
			for (int i = n; i > 0; i--) {
				for (int j = 0; j < n; i++) {
					if (chk[i][j] && !a[i][j]) {
						a[i][j] = a[i - 1][j];
						a[i - 1][j] = 0;
						chk[i - 1][j] = 1;
					}
				}

			}
		}
		case 2: { // 좌
			for (int i = 0; i < n - 1; i++) {
				for (int j = 0; j < n; j++) {
					if (chk[j][i]) continue;
					if (a[j][i] == a[j][i + 1]) {
						chk[j][i] = chk[j][i + 1] = 1;
						a[j][i] = a[j][i] * 2;
						a[j][i + 1] = 0;
						tMax = a[j][i] > tMax ? a[j][i] : tMax;
					}
				}
			}
			// 빈공간 당기기 chk된 곳이면서 0인곳
			for (int i = 0; i < n - 1; i++) {
				for (int j = 0; j < n; i++) {
					if (chk[j][i] && !a[j][i]) {
						a[j][i] = a[j][i + 1];
						a[j][i + 1] = 0;
						chk[j][i + 1] = 1;
					}
				}

			}
			break;
		}
		case 3: { // 우
			for (int i = n; i > 0; i--) {
				for (int j = 0; j < n; j++) {
					if (chk[j][i]) continue;
					if (a[j][i] == a[j][i - 1]) {
						chk[j][i] = chk[j][i - 1] = 1;
						a[j][i] = a[j][i] * 2;
						a[j][i - 1] = 0;
						tMax = a[j][i] > tMax ? a[j][i] : tMax;
					}
				}
			}
			// 빈공간 당기기 chk된 곳이면서 0인곳
			for (int i = n; i > 0; i--) {
				for (int j = 0; j < n; i++) {
					if (chk[j][i] && !a[j][i]) {
						a[j][i] = a[j][i - 1];
						a[j][i - 1] = 0;
						chk[j][i - 1] = 1;
					}
				}

			}
			break;
		}
		default:
			break;
		}
	}

	for (int i = 0; i < 4; i++) {
		go(a, i, cnt + 1);
	}

	Max = tMax > Max ? tMax : Max;
}

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%d", &arr[i][j]);
		}
	}

	go(arr, -1, 0);

	printf("%d", Max);

	return 0;
}
```





백준 12100 2048 boj acmicpc

