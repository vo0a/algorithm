## [BOJ] #15686 치킨 배달

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 512 MB      | 40.856%   |

[문제](https://www.acmicpc.net/problem/15686)



| 메모리 | 시간 |
| ------ | ---- |
| KB     | 0 ms |

```c++
#include <iostream>
#include <queue>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int, int> p;
int arr[55][55], n, m, ans; // m: 선택할 치킨집 개수
int dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 };

queue<p> homeAdr;
// 해당 집과의 거리가 몇인지도 알아야되고, 집 주소 i, j 도 알아야함
struct Home {
	int cnt;
	vector<pair< int, p >> homeInfo; // distance, address
};
map<p, Home> chicken;
vector<pair<int, p>> sortChicken;

void countDistance() {
	while (!homeAdr.empty()) {
		queue<pair<int, p>> q;
		p front = homeAdr.front();
		homeAdr.pop();
		
		int chk[55][55] = { 0 };
		q.push({ 0, {front.first, front.second} });
		chk[front.first][front.second] = 1;
		while (!q.empty()) {
			auto f = q.front();
			q.pop();

			int x = f.second.first, y = f.second.second;
			if (arr[x][y] == 2) {
				chicken[{x, y}].homeInfo.push_back({ f.first, {front.first, front.second} });
				chicken[{x, y}].cnt++;
				ans += f.first; // 치킨거리
				break;
			}

			for (int i = 0; i < 4; i++) {
				int nx = x + dx[i], ny = y + dy[i];
				if (nx < 0 || ny < 0 || nx >= n || ny >= n || chk[nx][ny]) continue;
				chk[nx][ny] = 1;
				q.push({ f.first + 1, {nx, ny} });
			}
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%d", &arr[i][j]);
			if (arr[i][j] == 1) {
				homeAdr.push({i, j});
			}
		}
	}
	countDistance();

	// 정렬을 위해 옮겨담기
	for (auto e : chicken) {
		sortChicken.push_back({ e.second.cnt , {e.first.first, e.first.second} });
	}
	sort(sortChicken.begin(), sortChicken.end(), greater<>());

	// m개의 치킨집 선택 후
	int count = 0;
	for (auto e : sortChicken) {
		if (count < m) count++;
		else {
			arr[e.second.first][e.second.second] = 0;
			for (auto x : chicken[{e.second.first, e.second.second}].homeInfo) {
				homeAdr.push({ x.second.first, x.second.second });
				ans -= x.first; // 치킨거리
			}
		}
	}

	// 치킨 거리 다시 재고
	countDistance();

	// 출력
	printf("%d", ans);

	return 0;
}
```

- map 는 key 기준으로 정렬하기 때문에 원하던 방법대로 정렬할 수 없었음.
- 따라서, vector로 옮겨담아 정렬함.
  - 그런데 문제는 cnt가 동일할 때 가장 하단과 가까운 치킨 가게가 선택되는데, 중간에 있는 치킨 집을 선택해야될 때가 있음. 이 때는 어떻게 선택해야할지 고민.



백준 15686 치킨 배달 boj acmicpc

