## [BOJ] #15686 치킨 배달

| 시간 제한 | 메모리 제한 | 정답 비율 |
| --------- | ----------- | --------- |
| 1 초      | 512 MB      | 40.856%   |

[문제](https://www.acmicpc.net/problem/15686)



| 메모리 | 시간 |
| ------ | ---- |
| KB     | 0 ms |

```c++
#include <iostream>
#include <queue>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int, int> p;
int arr[55][55], n, m, ans; // m: 선택할 치킨집 개수
int dx[] = { 0, 1, 0, -1 }, dy[] = { 1, 0, -1, 0 };

queue<p> homeAdr;
// 해당 집과의 거리가 몇인지도 알아야되고, 집 주소 i, j 도 알아야함
struct Home {
	int cnt;
	vector<pair< int, p >> homeInfo; // distance, address
};
map<p, Home> chicken;

// cnt 기준 내림차순
bool cmp(map<p, Home> a, map<p, Home> b) {
	map<p, Home>::iterator iterA = a.begin();
	map<p, Home>::iterator iterB = b.begin();
	if (iterA->second.cnt == iterB->second.cnt) {
		return iterA->first.first < iterB->first.first;
	}
	return iterA->second.cnt > iterB->second.cnt;
}

void countDistance() {
	while (!homeAdr.empty()) {
		queue<pair<int, p>> q;
		p front = homeAdr.front();
		homeAdr.pop();
		
		int chk[55][55] = { 0 };
		q.push({ 0, {front.first, front.second} });
		chk[front.first][front.second] = 1;
		while (!q.empty()) {
			auto f = q.front();
			q.pop();

			int x = f.second.first, y = f.second.second;
			if (arr[x][y] == 2) {
				chicken[{x, y}].homeInfo.push_back({ f.first, {front.first, front.second} });
				chicken[{x, y}].cnt++;
				ans += f.first; // 치킨거리
				break;
			}

			for (int i = 0; i < 4; i++) {
				int nx = x + dx[i], ny = y + dy[i];
				if (nx < 0 || ny < 0 || nx >= n || ny >= n || arr[nx][ny] == 1 || chk[nx][ny]) continue;
				chk[nx][ny] = 1;
				q.push({ f.first + 1, {nx, ny} });
			}
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%d", &arr[i][j]);
			if (arr[i][j] == 1) {
				homeAdr.push({i, j});
			}
		}
	}
	countDistance();

	// m개의 치킨집 선택 후
	//sort(chicken.begin(), chicken.end(), cmp);
	int count = 0;
	for (auto e : chicken) {
		if(count < m) count++;
		else {
			arr[e.first.first][e.first.second] = 0;
			for (auto x : e.second.homeInfo) {
				homeAdr.push({ x.second.first, x.second.second });
				ans -= x.first; // 치킨거리
			}
		}
	}

	// 치킨 거리 다시 재고
	countDistance();

	// 출력
	printf("%d", ans);

	return 0;
}
```

정렬하는 부분 더 찾아보기. sort()함수에 인자가 부족하다는 이상한 오류가 뜸.. 



백준 15686 치킨 배달 boj acmicpc

